#/bin/sh
###############################################################
#  $Author$
#  $Date$
#  $Revision$
#
#  Copyright 2001 California Institute of Technology
#
###############################################################

.SUFFIXES :
.SUFFIXES : .cpp .d .o .dh .h .h.gch

OBJDIR = .

# LOCAL_DEFNS=-DDEBUG_PATHS
CXX_FLAGS = @CXXFLAGS@ $(CXX_OPT) $(LOCAL_DEFNS)

EXT        = ../../ext

#----------------------
#  kernel components
#----------------------

# basic components always needed
BASE       = State.o Elements.o Constituents.o stringUtils.o misc.o importCTML.o plots.o \
             xml.o Phase.o DenseMatrix.o ctml.o funcs.o ctvector.o phasereport.o ct2ctml.o

# thermodynamic properties
THERMO     = $(BASE) ThermoPhase.o IdealGasPhase.o ConstDensityThermo.o StoichSubstance.o PureFluidPhase.o SpeciesThermoFactory.o ThermoFactory.o

# homogeneous kinetics
KINETICS   = GRI_30_Kinetics.o KineticsFactory.o GasKinetics.o FalloffFactory.o \
             ReactionStoichMgr.o $(THERMO)

# heterogeneous kinetics
HETEROKIN = InterfaceKinetics.o ImplicitSurfChem.o SurfPhase.o EdgeKinetics.o $(THERMO)

# support for importing from Chemkin-compatible reaction mechanisms
CK         = $(KINETICS)

# chemical equilibrium
EQUIL      = ChemEquil.o MultiPhaseEquil.o sort.o $(THERMO)

# reaction path analysis
RPATH      = Group.o ReactionPath.o

# solvers
SOLVERS    = CVode.o  BandMatrix.o 

# 1D flow models
FLOW1D     =  $(KINETICS) $(SOLVERS)


EVERYTHING = $(KINETICS) $(HETEROKIN) $(ELECTROCHEM) $(EQUIL) $(CK) \
             $(TRANSPORT) $(REACTOR) $(RPATH) $(SOLVERS) $(FLOW1D)

PCH = 
#config.h ct_defs.h utilities.h ThermoPhase.h Kinetics.h ReactionData.h RateCoeffMgr.h ReactionStoichMgr.h

PCHGCH = $(PCH:.h=.h.gch)

all:  config.h $(PCHGCH) @KERNEL@ lib

config.h: ../../config.h
	cp -f ../../config.h ./config.h

%.h.gch : %.h
ifeq (@precompile_headers@,yes)
	@CXX@ $*.h $(CXX_FLAGS) 
else
	@echo 'skipping precompiling header file $*.h'
endif


base: $(BASE)

thermo: $(THERMO)

kinetics: $(KINETICS) $(HETEROKIN)

ck: 
	cd converters; @MAKE@

equil: $(EQUIL)

flow1d: $(FLOW1D)

trprops:
	cd transport; @MAKE@

reactor:
	cd zeroD; @MAKE@

rpath: $(RPATH)

solvers: $(SOLVERS)

tpx: 
	cd $(EXT)/tpx; @MAKE@

flow1D:
	cd oneD;  @MAKE@

CXX_LIBS = @LIBS@
CXX_INCLUDES = -I.
CANTERA_LIB = @buildlib@/libcantera.a

DEPENDS = $(EVERYTHING:.o=.d)
SRCS = $(EVERYTHING:.o=.cpp)

.cpp.d:
	g++ -MM $(CXX_INCLUDES) $*.cpp > $*.d

.cpp.o:
	@CXX@ -c $< $(CXX_FLAGS) 
#$(CXX_INCLUDES)

.f.o:
	@F77@ -c $< $(F77_FLAGS) 

#
# HKM note: The lib function below removes the library first.
#           I was having trouble linking applications on linux
#           without removing the cantera library first.
# suggest the following change:
#
# lib:
#        @(if [ `ls -1t $(CANTERA_LIB) *.o | head -1` != $(CANTERA_LIB) ] ; then \
#         $(RM) $(CANTERA_LIB) ; echo 'ar ruv ' $(CANTERA_LIB) '*.o' ; \
#         ar ruv $(CANTERA_LIB) *.o   ; fi)
#           
lib: 
	$(RM)     $(CANTERA_LIB)
	@ARCHIVE@ $(CANTERA_LIB) *.o > /dev/null
	cd ../.. ; @MAKE@ hdr-collect

clean:
	$(RM) *.o *.gch *~ $(CANTERA_LIB)
	cd zeroD; @MAKE@ clean
	cd oneD;  @MAKE@ clean
	cd converters; @MAKE@ clean
	cd transport; @MAKE@ clean

depends: $(DEPENDS)
	cat *.d > .depends
	$(RM) $(DEPENDS) 
	cd oneD; @MAKE@ depends
	cd zeroD; @MAKE@ depends
	cd converters; @MAKE@ depends
	cd transport; @MAKE@ depends

TAGS: 
	etags *.h *.cpp

ifeq ($(wildcard .depends), .depends)
include .depends
endif
